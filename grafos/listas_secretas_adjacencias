#include <iostream>
#include <list>
using namespace std;

struct no {
    int v;   //vertice
    int peso; // nao usado aqui
};

//funçao para inserir as arestas no grafo
void cria_aresta(list<no> adj[], int u, int v, int p, int orientado) 
{
    no aux;
    aux.v = v;  //recebe o vertice
    aux.peso = p;   //inicia com zero
    adj[u].push_back(aux);   //insere v na lista de adjacencias de u

    if (orientado == 0) //se nao for orientado cria o vertice de volta
    {
        aux.v = u;    //volta para u
        adj[v].push_back(aux);   //insere u na lista de adjacencias de v
    }
}

// Função de ordenação bubble sort
void ordena(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1])  //troca os elementos
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int N, M; 
    cin >> N >> M;  //lendo as cidades e caminhos 

    list<no> adj[N + 1]; // crie um vetor de lista de adjacencia

    for (int i = 0; i < M; i++)  //lendo as arestas
    {
        int u, v;
        cin >> u >> v;   //lendo duas cidades conectadas
        cria_aresta(adj, u, v, 0, 0);  //cria aresta sem peso (grafo nao orientado)
    }

    for (int i = 1; i <= N; i++) 
    {
        int vizinhos[100];    // armazena os vizinhos de i
        int k = 0;   //contador

        for (auto it = adj[i].begin(); it != adj[i].end(); it++) //percorre a lista de adjacencias da cidade
        {
            vizinhos[k++] = it->v;  //adiciona o vizinho no array
        }

        ordena(vizinhos, k);  //ordena em ordem crescente

        cout << k;  //imprimindo a quantidade de vizinhos
        for (int j = 0; j < k; j++) 
        {
            cout << " " << vizinhos[j];   //imprimindo cada vizinho em ordem crescente
        }
        cout << endl;
    }

    return 0;
}
